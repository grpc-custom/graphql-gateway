// Code generated by protoc-gen-graphql-gateway. DO NOT EDIT.
// source: example/federation/proto/account/account.proto

/*
Package account is a reverse proxy.

It translates gRPC into GraphQL.
*/
package account

import (
	"context"

	"github.com/graphql-go/graphql"
	"github.com/grpc-custom/graphql-gateway/runtime"
	"github.com/grpc-custom/graphql-gateway/runtime/cache"
	"github.com/grpc-custom/graphql-gateway/runtime/errors"
	"github.com/grpc-custom/graphql-gateway/runtime/scalar"
	"golang.org/x/sync/singleflight"
	"google.golang.org/grpc"
	"google.golang.org/grpc/grpclog"
)

var (
	userType = graphql.NewObject(graphql.ObjectConfig{
		Name: "User",
		Fields: graphql.Fields{
			"id": &graphql.Field{
				Type: scalar.String,
			},
			"name": &graphql.Field{
				Type: scalar.String,
			},
			"username": &graphql.Field{
				Type: scalar.String,
			},
		},
	})

	getMeRequestType = graphql.NewObject(graphql.ObjectConfig{
		Name:   "GetMeRequest",
		Fields: graphql.Fields{},
	})

	getMeResponseType = graphql.NewObject(graphql.ObjectConfig{
		Name: "GetMeResponse",
		Fields: graphql.Fields{
			"user": &graphql.Field{
				Type: graphql.NewNonNull(userType),
			},
		},
	})

	multiGetUsersRequestType = graphql.NewObject(graphql.ObjectConfig{
		Name: "MultiGetUsersRequest",
		Fields: graphql.Fields{
			"ids": &graphql.Field{
				Type: graphql.NewList(graphql.NewNonNull(scalar.String)),
			},
		},
	})

	multiGetUsersResponseType = graphql.NewObject(graphql.ObjectConfig{
		Name: "MultiGetUsersResponse",
		Fields: graphql.Fields{
			"users": &graphql.Field{
				Type: graphql.NewList(userType),
			},
		},
	})

	getUserRequestType = graphql.NewObject(graphql.ObjectConfig{
		Name: "GetUserRequest",
		Fields: graphql.Fields{
			"id": &graphql.Field{
				Type: graphql.NewNonNull(scalar.String),
			},
		},
	})

	getUserResponseType = graphql.NewObject(graphql.ObjectConfig{
		Name: "GetUserResponse",
		Fields: graphql.Fields{
			"user": &graphql.Field{
				Type: graphql.NewNonNull(userType),
			},
		},
	})
)

func RegisterGQLObjectTypes(mux *runtime.ServeMux) {
	mux.AddObjectType(userType)
}

type extendReviewAuthor interface {
	GetAuthorId() string
}

type accountServiceResolver struct {
	client AccountServiceClient
	group  singleflight.Group
	c      cache.Cache
}

func newAccountServiceResolver(client AccountServiceClient) *accountServiceResolver {
	return &accountServiceResolver{
		client: client,
		group:  singleflight.Group{},
		c:      cache.New(100),
	}
}

func (r *accountServiceResolver) FieldGetMe() *graphql.Field {
	field := &graphql.Field{
		Name:        "/account.AccountService/GetMe",
		Description: "",
		Type:        graphql.NewNonNull(userType),
		Args:        graphql.FieldConfigArgument{},
		Resolve:     r.resolveGetMe,
	}
	return field
}

func (r *accountServiceResolver) resolveGetMe(p graphql.ResolveParams) (interface{}, error) {
	in := &GetMeRequest{}
	ctx := runtime.Context(p.Context)
	if timeout := runtime.GrpcTimeout(ctx); timeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}
	out, err := r.client.GetMe(ctx, in)
	if err != nil {
		return nil, errors.ToGraphQLError(err)
	}
	return out.User, nil
}

func (r *accountServiceResolver) extendReviewAuthor() *graphql.Field {
	return &graphql.Field{
		Type: graphql.NewNonNull(userType),
		Resolve: func(p graphql.ResolveParams) (interface{}, error) {
			ctx := runtime.Context(p.Context)
			src, ok := p.Source.(extendReviewAuthor)
			if !ok {
				return nil, errors.ErrWrongType
			}
			args := p.Args
			args["id"] = src.GetAuthorId()
			return r.resolveGetUser(ctx, args)
		},
	}
}

func (r *accountServiceResolver) resolveGetUser(ctx context.Context, args map[string]interface{}) (interface{}, error) {
	in := new(GetUserRequest)
	valueId, ok := args["id"].(string)
	if !ok {
		valueId = ""
	}
	in.Id = valueId
	if timeout := runtime.GrpcTimeout(ctx); timeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}
	out, err := r.client.GetUser(ctx, in)
	if err != nil {
		return nil, errors.ToGraphQLError(err)
	}
	return out.User, nil
}

func RegisterAccountServiceFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.DialContext(ctx, endpoint, opts...)
	if err != nil {
		return
	}
	defer func() {
		if err != nil {
			if e := conn.Close(); e != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, e)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if e := conn.Close(); e != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, e)
			}
		}()
	}()
	return RegisterAccountServiceHandler(mux, conn)
}

func RegisterAccountServiceHandler(mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterAccountServiceHandlerClient(mux, NewAccountServiceClient(conn))
}

func RegisterAccountServiceHandlerClient(mux *runtime.ServeMux, client AccountServiceClient) error {
	svc := newAccountServiceResolver(client)
	// gRPC /account.AccountService/GetMe
	mux.AddQuery("me", svc.FieldGetMe())
	// extend Review.author
	mux.AddField("Review", "author", svc.extendReviewAuthor())
	return nil
}
