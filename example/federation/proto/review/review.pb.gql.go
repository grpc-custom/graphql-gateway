// Code generated by protoc-gen-graphql-gateway. DO NOT EDIT.
// source: example/federation/proto/review/review.proto

/*
Package review is a reverse proxy.

It translates gRPC into GraphQL.
*/
package review

import (
	"context"
	"time"

	"github.com/graphql-go/graphql"
	"github.com/grpc-custom/graphql-gateway/runtime"
	"github.com/grpc-custom/graphql-gateway/runtime/cache"
	"github.com/grpc-custom/graphql-gateway/runtime/errors"
	"github.com/grpc-custom/graphql-gateway/runtime/scalar"
	"golang.org/x/sync/singleflight"
	"google.golang.org/grpc"
	"google.golang.org/grpc/grpclog"
)

var (
	reviewType = graphql.NewObject(graphql.ObjectConfig{
		Name: "Review",
		Fields: graphql.Fields{
			"id": &graphql.Field{
				Type: scalar.String,
			},
			"body": &graphql.Field{
				Type: scalar.String,
			},
		},
	})

	listUserReviewsRequestType = graphql.NewObject(graphql.ObjectConfig{
		Name: "ListUserReviewsRequest",
		Fields: graphql.Fields{
			"userId": &graphql.Field{
				Type: graphql.NewNonNull(scalar.String),
			},
			"first": &graphql.Field{
				Type: graphql.NewNonNull(scalar.Int32),
			},
		},
	})

	listUserReviewsResponseType = graphql.NewObject(graphql.ObjectConfig{
		Name: "ListUserReviewsResponse",
		Fields: graphql.Fields{
			"reviews": &graphql.Field{
				Type: graphql.NewList(graphql.NewNonNull(reviewType)),
			},
		},
	})

	listProductReviewsRequestType = graphql.NewObject(graphql.ObjectConfig{
		Name: "ListProductReviewsRequest",
		Fields: graphql.Fields{
			"productId": &graphql.Field{
				Type: graphql.NewNonNull(scalar.String),
			},
		},
	})

	listProductReviewsResponseType = graphql.NewObject(graphql.ObjectConfig{
		Name: "ListProductReviewsResponse",
		Fields: graphql.Fields{
			"reviews": &graphql.Field{
				Type: graphql.NewList(graphql.NewNonNull(reviewType)),
			},
		},
	})
)

func RegisterGQLObjectTypes(mux *runtime.ServeMux) {
	mux.AddObjectType(reviewType)
}

type extendUserReviews interface {
	GetId() string
}

type extendProductReviews interface {
	GetUpc() string
}

type reviewServiceResolver struct {
	client ReviewServiceClient
	group  singleflight.Group
	c      cache.Cache
}

func newReviewServiceResolver(client ReviewServiceClient) *reviewServiceResolver {
	return &reviewServiceResolver{
		client: client,
		group:  singleflight.Group{},
		c:      cache.New(100),
	}
}

func (r *reviewServiceResolver) extendUserReviews() *graphql.Field {
	return &graphql.Field{
		Type: graphql.NewList(graphql.NewNonNull(reviewType)),
		Resolve: func(p graphql.ResolveParams) (interface{}, error) {
			ctx := runtime.Context(p.Context)
			src, ok := p.Source.(extendUserReviews)
			if !ok {
				return nil, errors.ErrWrongType
			}
			args := p.Args
			args["userId"] = src.GetId()
			return r.resolveListUserReviews(ctx, args)
		},
	}
}

func (r *reviewServiceResolver) resolveListUserReviews(ctx context.Context, args map[string]interface{}) (interface{}, error) {
	in := new(ListUserReviewsRequest)
	valueUserId, ok := args["userId"].(string)
	if !ok {
		valueUserId = ""
	}
	in.UserId = valueUserId
	valueFirst, ok := args["first"].(int32)
	if !ok {
		valueFirst = 5
	}
	in.First = valueFirst
	// cache control max age: 30 second
	key := cache.GenerateKey("/review.ReviewService/ListUserReviews", in)
	value, ok := r.c.Get(key)
	if ok {
		ret := value.(*ListUserReviewsResponse)
		return ret.Reviews, nil
	}
	result, err, _ := r.group.Do(key, func() (interface{}, error) {
		if timeout := runtime.GrpcTimeout(ctx); timeout > 0 {
			var cancel context.CancelFunc
			ctx, cancel = context.WithTimeout(ctx, timeout)
			defer cancel()
		}
		return r.client.ListUserReviews(ctx, in)
	})
	if err != nil {
		return nil, errors.ToGraphQLError(err)
	}
	r.c.Set(key, result, 30*time.Second)
	ret := result.(*ListUserReviewsResponse)
	return ret.Reviews, nil
}

func (r *reviewServiceResolver) extendProductReviews() *graphql.Field {
	return &graphql.Field{
		Type: graphql.NewList(graphql.NewNonNull(reviewType)),
		Resolve: func(p graphql.ResolveParams) (interface{}, error) {
			ctx := runtime.Context(p.Context)
			src, ok := p.Source.(extendProductReviews)
			if !ok {
				return nil, errors.ErrWrongType
			}
			args := p.Args
			args["productId"] = src.GetUpc()
			return r.resolveListProductReviews(ctx, args)
		},
	}
}

func (r *reviewServiceResolver) resolveListProductReviews(ctx context.Context, args map[string]interface{}) (interface{}, error) {
	in := new(ListProductReviewsRequest)
	valueProductId, ok := args["productId"].(string)
	if !ok {
		valueProductId = ""
	}
	in.ProductId = valueProductId
	if timeout := runtime.GrpcTimeout(ctx); timeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}
	out, err := r.client.ListProductReviews(ctx, in)
	if err != nil {
		return nil, errors.ToGraphQLError(err)
	}
	return out.Reviews, nil
}

func RegisterReviewServiceFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.DialContext(ctx, endpoint, opts...)
	if err != nil {
		return
	}
	defer func() {
		if err != nil {
			if e := conn.Close(); e != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, e)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if e := conn.Close(); e != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, e)
			}
		}()
	}()
	return RegisterReviewServiceHandler(mux, conn)
}

func RegisterReviewServiceHandler(mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterReviewServiceHandlerClient(mux, NewReviewServiceClient(conn))
}

func RegisterReviewServiceHandlerClient(mux *runtime.ServeMux, client ReviewServiceClient) error {
	svc := newReviewServiceResolver(client)
	// extend User.reviews
	mux.AddField("User", "reviews", svc.extendUserReviews())
	// extend Product.reviews
	mux.AddField("Product", "reviews", svc.extendProductReviews())
	return nil
}
